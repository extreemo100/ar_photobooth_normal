<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Camera & Video App</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
        }
        
        /* Canvas container - dynamically sized */
        #canvas-container {
            position: relative;
            cursor: default;
        }
        
        #canvas-container.dragging-overlay {
            cursor: grabbing;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 00px;
            max-width: 100%;
        }
        
        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
            font-size: 14px;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 1);
        }
        
        button:disabled {
            background: rgba(150, 150, 150, 0.5);
            cursor: not-allowed;
        }
        
        .video-btn {
            padding: 8px 12px;
            font-size: 12px;
            background: rgba(100, 100, 255, 0.8);
            color: white;
            transition: all 0.2s;
            width: 100%;
        }
        
        .video-btn:hover {
            background: rgba(120, 120, 255, 0.9);
        }
        
        .video-btn.active {
            background: rgba(0, 200, 100, 0.9);
            box-shadow: 0 0 10px rgba(0, 255, 100, 0.5);
        }
        
        #video-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100px;
        }
        
        select {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 90%;
        }
        
        #device-info {
            position: absolute;
            bottom: 60px;
            right: 20px;
            color: white;
            background: rgba(0, 100, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
        }
        
        #overlay-info {
            position: absolute;
            bottom: 140px;
            right: 20px;
            color: white;
            background: rgba(255, 100, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
            display: none;
        }

        
        #photo-preview, #video-preview {
            position: absolute;
            bottom: 10px;
            right: 10px;
            max-width: 250px;
            max-height: 180px;
            border: 2px solid white;
            border-radius: 5px;
            z-index: 100;
            display: none;
        }
        
        #recording-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            z-index: 200;
            display: none;
            animation: pulse 1s infinite;
        }
        
        /* Hidden video element for camera */
        #camera-video {
            position: absolute;
            visibility: hidden;
            width: 1px;
            height: 1px;
            -webkit-playsinline: true;
            -webkit-user-select: none;
        }
        
        /* Format selector for desktop */
        #format-selector {
            position: absolute;
            bottom: 60px;
            left: 20px;
            z-index: 100;
            display: none;
        }
        
        .format-button {
            margin-right: 1px;
            padding: 2px 2px;
            background: rgba(100, 100, 255, 0.8);
            color: white;
            border: 2px solid transparent;
        }
        
        .format-button.active {
            background: rgba(0, 255, 0, 0.8);
            border-color: white;
        }
        
        /* Mobile adjustments */
        @media (max-width: 768px) {
            button, select {
                font-size: 12px;
                padding: 2px 2px;
            }
            
            #controls {
                gap: 5px;
            }
            
            .control-group {
                gap: 5px;
            }
            
            #video-controls {
                width: 80px;
                right: 10px;
                top: 10px;
            }
            
            .video-btn {
                padding: 6px 8px;
                font-size: 10px;
            }
            
            #device-info {
                bottom: 50px;
                right: 10px;
            }
            
            #overlay-info {
                bottom: 120px;
                right: 10px;
            }
            
            /* Show switch camera button on mobile */
            #switchCamera {
                display: inline-block !important;
            }
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        <!-- Hidden video element for camera -->
        <video id="camera-video" autoplay playsinline webkit-playsinline></video>
        
        <div id="controls">
            <div class="control-group">
                <button id="startCamera">Start Camera</button>
                <button id="stopCamera" disabled>Stop Camera</button>
                <button id="switchCamera" disabled style="display: none;">Switch Camera</button>
            </div>
            <div class="control-group">
                <button id="takePhoto">Take Photo</button>
                <button id="recordVideo">Record 10s Video</button>
                <button id="stopRecording" disabled style="display: none;">Stop Recording</button>
            </div>
        </div>
        
        <div id="video-controls">
            <button class="video-btn" data-video="video1">Gojo</button>
            <button class="video-btn" data-video="video2">Luffy</button>
            <button class="video-btn" data-video="video3">Batman</button>
            <button class="video-btn" data-video="video4">Deku</button>
            <button class="video-btn" data-video="video5">Goku</button>
            <button class="video-btn" data-video="video6">Nezuko</button>
            <button class="video-btn" data-video="video7">Naruto</button>
            <button class="video-btn" data-video="video8">Totoro</button>
            <button class="video-btn" data-video="video9">Hatsune Miku</button>
            <button class="video-btn" data-video="video10">Pikachu</button>
            <button class="video-btn" data-video="video11">Darth Vader</button>
            <button class="video-btn" data-video="video12">Charizard</button>
        </div>
        
        <div id="device-info"></div>
        <div id="overlay-info">
            Overlay Position<br>
            <span id="overlay-pos">X: 0, Y: 0</span><br>
            <span id="overlay-scale">Scale: 1.0</span>
        </div>

        <div id="status">Ready to start</div>
        
        <div id="format-selector">
            <button class="format-button" id="portrait-btn" data-format="portrait">Portrait (9:16)</button>
            <button class="format-button" id="landscape-btn" data-format="landscape">Landscape (16:9)</button>
            <button class="format-button" id="square-btn" data-format="square">Square (1:1)</button>
        </div>
        
        <img id="photo-preview" alt="Photo preview">
        <video id="video-preview" alt="Video preview" controls></video>
        <div id="recording-indicator">ðŸ”´ RECORDING<br><span id="countdown">10</span>s</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Device detection and format configuration
        const deviceInfo = {
            isMobile: false,
            isTablet: false,
            isDesktop: false,
            os: '',
            format: 'landscape' // default
        };
        
        const formatConfigs = {
            portrait: {
                width: 1080,
                height: 1920,
                aspectRatio: 9/16,
                planeWidth: 9,
                planeHeight: 16,
                cameraZ: 10,
                videoPlaneWidth: 3,
                videoPlaneHeight: 5.33,
                videoPlaneX: -1.72,
                videoPlaneY:-0.84,
                modelX: -3,
                modelY: -2,
                modelScale: 1.5
            },
            landscape: {
                width: 1920,
                height: 1080,
                aspectRatio: 16/9,
                planeWidth: 32,
                planeHeight: 9,
                cameraZ: 5,
                videoPlaneWidth: 4,
                videoPlaneHeight: 3,
                videoPlaneX: 2,
                modelX: -2,
                modelY: -1,
                modelScale: 1
            },
            square: {
                width: 1080,
                height: 1080,
                aspectRatio: 1,
                planeWidth: 12,
                planeHeight: 12,
                cameraZ: 7,
                videoPlaneWidth: 3.5,
                videoPlaneHeight: 3.5,
                videoPlaneX: 2.5,
                modelX: -2.5,
                modelY: -1.5,
                modelScale: 1.2
            }
        };
        
        let currentFormat;
        
        // Three.js variables
        let scene, camera, renderer, cameraTexture, videoTexture;
        let cameraStream, videoElement;
        let backgroundPlane, videoPlane, pngOverlayPlane;
        let isVideoPlaying = false;
        let currentActiveVideo = null; // Track which video button is active
        let cameraVideo;
        let currentCameraFacing = 'user'; // 'user' for front, 'environment' for back
        
        // PNG Overlay configuration
        const pngOverlayUrl = 'overlay10.png'; // Change this to your PNG file path
        const pngOverlayConfig = {
            scale: .2,      // 1.0 = full size, 0.5 = half size, 2.0 = double size
            positionX: 0,    // Horizontal position (0 = center, negative = left, positive = right)
            positionY: 2.5  // Vertical position (0 = center, negative = down, positive = up)
        };
        
        // Video recording variables
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let recordingTimer;
        let countdownTimer;
        
        // ========== FRAME TIMING FOR SMOOTH RECORDING ==========
        let lastFrameTime = 0;
        const TARGET_FPS = 30;
        const FRAME_DURATION = 1000 / TARGET_FPS;
        let animationFrameId = null;
        
        // ========== VIDEO OVERLAY INTERACTION VARIABLES ==========
        let isDraggingOverlay = false;
        let overlayDragStart = { x: 0, y: 0 };
        let overlayPositionStart = { x: -1.72, y: 0 };
        let overlayScale = 1.4;
        let overlayBaseWidth, overlayBaseHeight;
        let raycaster, mouse;
        let initialPinchDistance = 0;
        let initialPinchScale = 1;
        let activeInteraction = null; // 'overlay' or null
        
        const videoUrls = {
            video1: 'gojo1.webm',
            video2: 'luffy2.webm',
            video3: 'batman2.webm',
            video4: 'deku3.webm',
            video5: 'goku1.webm',
            video6: 'nezuko2.webm',
            video7: 'nar1.webm',
            video8: 'totoro2.webm',
            video9: 'miku3.webm',
            video10: 'pika2.webm',
            video11: 'darth3.webm',
            video12: 'char2.webm'
        };
        
        function detectDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            
            // Detect mobile devices
            if (/android/i.test(userAgent)) {
                deviceInfo.isMobile = true;
                deviceInfo.os = 'Android';
            } else if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
                deviceInfo.isMobile = true;
                deviceInfo.os = 'iOS';
            } else if (/windows phone/i.test(userAgent)) {
                deviceInfo.isMobile = true;
                deviceInfo.os = 'Windows Phone';
            }
            
            // Detect tablets
            if (/tablet|ipad/i.test(userAgent) || (window.innerWidth >= 768 && window.innerWidth <= 1024)) {
                deviceInfo.isTablet = true;
                deviceInfo.isMobile = false;
            }
            
            // Detect desktop
            if (!deviceInfo.isMobile && !deviceInfo.isTablet) {
                deviceInfo.isDesktop = true;
                deviceInfo.os = 'Desktop';
            }
            
            // Set default format based on device
            if (deviceInfo.isMobile) {
                deviceInfo.format = 'portrait'; // Instagram story format for mobile
            } else if (deviceInfo.isTablet) {
                deviceInfo.format = 'square'; // Square format for tablets
            } else {
                deviceInfo.format = 'landscape'; // Landscape for desktop
                // Show format selector on desktop
                document.getElementById('format-selector').style.display = 'block';
            }
            
            // Update device info display
            const infoDiv = document.getElementById('device-info');
            infoDiv.innerHTML = `
                Device: ${deviceInfo.os}<br>
                Format: ${deviceInfo.format.toUpperCase()}<br>
                ${currentFormat ? `${currentFormat.width}x${currentFormat.height}` : ''}
            `;
            
            return deviceInfo;
        }
        
        function updateFormat(format) {
            deviceInfo.format = format;
            currentFormat = formatConfigs[format];
            
            // Update UI
            document.querySelectorAll('.format-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-format="${format}"]`)?.classList.add('active');
            
            // Update device info display
            document.getElementById('device-info').innerHTML = `
                Device: ${deviceInfo.os}<br>
                Format: ${format.toUpperCase()}<br>
                ${currentFormat.width}x${currentFormat.height}
            `;
            
            // Recreate scene with new dimensions
            if (scene) {
                recreateScene();
            }
        }
        
        function recreateScene() {
            const config = currentFormat;
            
            // Update camera
            camera.aspect = config.aspectRatio;
            camera.position.z = config.cameraZ;
            camera.updateProjectionMatrix();
            
            // Update background plane
            if (backgroundPlane) {
                scene.remove(backgroundPlane);
                
                // Create plane at format dimensions
                const backgroundGeometry = new THREE.PlaneGeometry(config.planeWidth, config.planeHeight);
                
                // Recalculate texture cropping if camera is active
                if (cameraTexture && cameraVideo.videoWidth && cameraVideo.videoHeight) {
                    const cameraAspectRatio = cameraVideo.videoWidth / cameraVideo.videoHeight;
                    const formatAspect = config.planeWidth / config.planeHeight;
                    
                    console.log(`Format switched - recalculating crop`);
                    console.log(`Camera: ${cameraVideo.videoWidth}x${cameraVideo.videoHeight} (aspect: ${cameraAspectRatio.toFixed(2)})`);
                    console.log(`New format: ${config.planeWidth}x${config.planeHeight} (aspect: ${formatAspect.toFixed(2)})`);
                    
                    // Apply "cover" behavior - fill entire plane, crop excess
                    if (cameraAspectRatio > formatAspect) {
                        // Camera wider - crop sides
                        const cropX = formatAspect / cameraAspectRatio;
                        cameraTexture.repeat.set(cropX, 1);
                        cameraTexture.offset.set((1 - cropX) / 2, 0);
                        console.log(`Cover mode: cropping sides (showing ${(cropX * 100).toFixed(1)}% of width)`);
                    } else if (cameraAspectRatio < formatAspect) {
                        // Camera taller - crop top/bottom
                        const cropY = cameraAspectRatio / formatAspect;
                        cameraTexture.repeat.set(1, cropY);
                        cameraTexture.offset.set(0, (1 - cropY) / 2);
                        console.log(`Cover mode: cropping top/bottom (showing ${(cropY * 100).toFixed(1)}% of height)`);
                    } else {
                        cameraTexture.repeat.set(1, 1);
                        cameraTexture.offset.set(0, 0);
                    }
                    cameraTexture.needsUpdate = true;
                    
                    backgroundPlane = new THREE.Mesh(backgroundGeometry, new THREE.MeshBasicMaterial({
                        map: cameraTexture,
                        side: THREE.DoubleSide
                    }));
                } else {
                    // No camera active, use existing material
                    backgroundPlane = new THREE.Mesh(backgroundGeometry, backgroundPlane.material);
                }
                
                backgroundPlane.position.z = -2;
                scene.add(backgroundPlane);
            }
            
            // Update video plane base dimensions and reset
            overlayBaseWidth = config.videoPlaneWidth;
            overlayBaseHeight = config.videoPlaneHeight;
            
            if (videoPlane) {
                scene.remove(videoPlane);
                const videoGeometry = new THREE.PlaneGeometry(
                    overlayBaseWidth * overlayScale, 
                    overlayBaseHeight * overlayScale
                );
                const videoMaterial = videoPlane.material;
                videoPlane = new THREE.Mesh(videoGeometry, videoMaterial);
                videoPlane.position.set(config.videoPlaneX, 0, 0);
                scene.add(videoPlane);
                updateOverlayInfo();
            }
            
            // Update PNG overlay plane
            if (pngOverlayPlane) {
                scene.remove(pngOverlayPlane);
                const pngOverlayGeometry = new THREE.PlaneGeometry(
                    config.planeWidth * pngOverlayConfig.scale, 
                    config.planeHeight * pngOverlayConfig.scale
                );
                const pngOverlayMaterial = pngOverlayPlane.material;
                pngOverlayPlane = new THREE.Mesh(pngOverlayGeometry, pngOverlayMaterial);
                pngOverlayPlane.position.set(pngOverlayConfig.positionX, pngOverlayConfig.positionY, 1);
                scene.add(pngOverlayPlane);
            }
            
            // Update renderer
            updateRendererSize();
        }
        
        function updateRendererSize() {
            const config = currentFormat;
            const container = document.getElementById('canvas-container');
            
            let width = 1000 ;
            let height = 2000;
            
            // Scale to fit window
            const windowAspect = window.innerWidth / window.innerHeight;
            const formatAspect = config.aspectRatio;
            
            if (windowAspect > formatAspect) {
                // Window is wider
                height = Math.min(window.innerHeight * 1.2, height);
                width = height * formatAspect;
            } else {
                // Window is taller
                width = Math.min(window.innerWidth * 1, width);
                height = width / formatAspect;
            }
            
            renderer.setSize(width, height);
            container.style.width = width + 'px';
            container.style.height = height + 'px';
        }
        
        function init() {
            // Detect device and set format
            detectDevice();
            currentFormat = formatConfigs[deviceInfo.format];
            
            // Store base overlay dimensions
            overlayBaseWidth = currentFormat.videoPlaneWidth;
            overlayBaseHeight = currentFormat.videoPlaneHeight;
            
            // Get reference to camera video element
            cameraVideo = document.getElementById('camera-video');
            
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera with device-specific settings
            const config = currentFormat;
            camera = new THREE.PerspectiveCamera(55, config.aspectRatio, 0.1, 1000);
            camera.position.z = config.cameraZ;
            
            // Create renderer with optimized settings for recording
            renderer = new THREE.WebGLRenderer({ 
                preserveDrawingBuffer: true,
                alpha: true,
                antialias: true,
                powerPreference: 'high-performance' // Request high-performance GPU
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x for performance
            renderer.setClearColor(0x000000, 0);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Create background plane for camera
            const backgroundGeometry = new THREE.PlaneGeometry(config.planeWidth, config.planeHeight);
            const backgroundMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0
            });
            backgroundPlane = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
            backgroundPlane.position.z = -2;
            scene.add(backgroundPlane);
            
            // Create video plane with transparent material
            const videoGeometry = new THREE.PlaneGeometry(config.videoPlaneWidth, config.videoPlaneHeight);
            const videoMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0,
                alphaTest: 0.1
            });
            videoPlane = new THREE.Mesh(videoGeometry, videoMaterial);
            videoPlane.position.set(config.videoPlaneX, 0, 0);
            scene.add(videoPlane);
            
            // Create PNG overlay plane (always on top)
            const pngOverlayGeometry = new THREE.PlaneGeometry(
                config.planeWidth * pngOverlayConfig.scale, 
                config.planeHeight * pngOverlayConfig.scale
            );
            const pngOverlayMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            pngOverlayPlane = new THREE.Mesh(pngOverlayGeometry, pngOverlayMaterial);
            pngOverlayPlane.position.set(pngOverlayConfig.positionX, pngOverlayConfig.positionY, 1); // In front of everything
            scene.add(pngOverlayPlane);
            
            // Load PNG overlay texture
            loadPngOverlay();
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Initialize raycaster for overlay interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Set up event listeners
            setupEventListeners();
            
            // Set up overlay interaction listeners
            setupOverlayInteraction();
            
            // Update renderer size
            updateRendererSize();
            
            // Start render loop
            animate();
            
            // Update button for active format
            if (deviceInfo.isDesktop) {
                document.querySelector(`[data-format="${deviceInfo.format}"]`).classList.add('active');
            }
            
            updateStatus(`Initialized for ${deviceInfo.os} in ${deviceInfo.format} mode. Click "Start Camera" to begin.`);
        }
        
        function loadPngOverlay() {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                pngOverlayUrl,
                (texture) => {
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    
                    pngOverlayPlane.material = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    pngOverlayPlane.material.needsUpdate = true;
                    console.log('PNG overlay loaded successfully');
                },
                undefined,
                (error) => {
                    console.log('PNG overlay not found or failed to load:', error);
                    // Keep the transparent material if PNG doesn't load
                }
            );
        }
        
        function setupEventListeners() {
            document.getElementById('startCamera').addEventListener('click', startCamera);
            document.getElementById('stopCamera').addEventListener('click', stopCamera);
            document.getElementById('switchCamera').addEventListener('click', switchCamera);
            document.getElementById('takePhoto').addEventListener('click', takePhoto);
            document.getElementById('recordVideo').addEventListener('click', recordVideo);
            document.getElementById('stopRecording').addEventListener('click', stopRecording);
            
            // Video toggle buttons
            document.querySelectorAll('.video-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const videoKey = e.target.getAttribute('data-video');
                    
                    // If clicking the same button that's active, stop the video
                    if (currentActiveVideo === videoKey) {
                        stopVideo();
                        return;
                    }
                    
                    // Otherwise, load the new video
                    loadVideo(videoKey);
                });
            });
            
            // Format selector buttons
            document.querySelectorAll('.format-button').forEach(btn => {
                btn.addEventListener('click', () => {
                    const format = btn.getAttribute('data-format');
                    updateFormat(format);
                });
            });
            
            window.addEventListener('resize', onWindowResize);
        }
        
        // ========== OVERLAY INTERACTION FUNCTIONS ==========
        function setupOverlayInteraction() {
            const container = document.getElementById('canvas-container');
            
            // Mouse events
            container.addEventListener('mousedown', onPointerDown);
            container.addEventListener('mousemove', onPointerMove);
            container.addEventListener('mouseup', onPointerUp);
            container.addEventListener('mouseleave', onPointerUp);
            
            // Touch events
            container.addEventListener('touchstart', onTouchStart, { passive: false });
            container.addEventListener('touchmove', onTouchMove, { passive: false });
            container.addEventListener('touchend', onTouchEnd);
            
            // Wheel for scaling
            container.addEventListener('wheel', onWheel, { passive: false });
        }
        
        function getMousePosition(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            return mouse;
        }
        
        function isOverOverlay(mousePos) {
            raycaster.setFromCamera(mousePos, camera);
            const intersects = raycaster.intersectObject(videoPlane);
            return intersects.length > 0;
        }
        
        function onPointerDown(event) {
            if (event.button !== 0) return; // Only left click
            
            const mousePos = getMousePosition(event);
            
            if (isOverOverlay(mousePos) && isVideoPlaying) {
                isDraggingOverlay = true;
                activeInteraction = 'overlay';
                overlayDragStart = { x: event.clientX, y: event.clientY };
                overlayPositionStart = { 
                    x: videoPlane.position.x, 
                    y: videoPlane.position.y 
                };
                document.getElementById('canvas-container').classList.add('dragging-overlay');
                event.preventDefault();
            }
        }
        
        function onPointerMove(event) {
            if (isDraggingOverlay && activeInteraction === 'overlay') {
                const deltaX = (event.clientX - overlayDragStart.x) / 50;
                const deltaY = -(event.clientY - overlayDragStart.y) / 50;
                
                videoPlane.position.x = overlayPositionStart.x + deltaX;
                videoPlane.position.y = overlayPositionStart.y + deltaY;
                
                updateOverlayInfo();
            } else {
                // Update cursor based on hover
                const mousePos = getMousePosition(event);
                const container = document.getElementById('canvas-container');
                
                if (isOverOverlay(mousePos) && isVideoPlaying) {
                    container.style.cursor = 'grab';
                } else {
                    container.style.cursor = 'default';
                }
            }
        }
        
        function onPointerUp(event) {
            if (isDraggingOverlay) {
                isDraggingOverlay = false;
                activeInteraction = null;
                document.getElementById('canvas-container').classList.remove('dragging-overlay');
            }
        }
        
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                
                if (isOverOverlay(mouse) && isVideoPlaying) {
                    isDraggingOverlay = true;
                    activeInteraction = 'overlay';
                    overlayDragStart = { x: touch.clientX, y: touch.clientY };
                    overlayPositionStart = { 
                        x: videoPlane.position.x, 
                        y: videoPlane.position.y 
                    };
                    event.preventDefault();
                }
            } else if (event.touches.length === 2 && isVideoPlaying) {
                // Pinch to scale
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                initialPinchScale = overlayScale;
                activeInteraction = 'overlay';
                event.preventDefault();
            }
        }
        
        function onTouchMove(event) {
            if (event.touches.length === 1 && isDraggingOverlay && activeInteraction === 'overlay') {
                const touch = event.touches[0];
                const deltaX = (touch.clientX - overlayDragStart.x) / 50;
                const deltaY = -(touch.clientY - overlayDragStart.y) / 50;
                
                videoPlane.position.x = overlayPositionStart.x + deltaX;
                videoPlane.position.y = overlayPositionStart.y + deltaY;
                
                updateOverlayInfo();
                event.preventDefault();
            } else if (event.touches.length === 2 && initialPinchDistance > 0 && activeInteraction === 'overlay') {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                
                const scaleFactor = currentDistance / initialPinchDistance;
                overlayScale = Math.max(0.5, Math.min(3, initialPinchScale * scaleFactor));
                
                updateOverlayScale();
                event.preventDefault();
            }
        }
        
        function onTouchEnd(event) {
            if (event.touches.length === 0) {
                isDraggingOverlay = false;
                initialPinchDistance = 0;
                activeInteraction = null;
            }
        }
        
        function onWheel(event) {
            const mousePos = getMousePosition(event);
            
            if (isOverOverlay(mousePos) && isVideoPlaying) {
                event.preventDefault();
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                overlayScale = Math.max(0.5, Math.min(3, overlayScale + delta));
                updateOverlayScale();
            }
        }
        
        function updateOverlayScale() {
            if (videoPlane) {
                const newWidth = overlayBaseWidth * overlayScale;
                const newHeight = overlayBaseHeight * overlayScale;
                
                const currentPos = videoPlane.position.clone();
                const currentMaterial = videoPlane.material;
                
                scene.remove(videoPlane);
                const newGeometry = new THREE.PlaneGeometry(newWidth, newHeight);
                videoPlane = new THREE.Mesh(newGeometry, currentMaterial);
                videoPlane.position.copy(currentPos);
                scene.add(videoPlane);
                
                updateOverlayInfo();
            }
        }
        
        function updateOverlayInfo() {
            const posElement = document.getElementById('overlay-pos');
            const scaleElement = document.getElementById('overlay-scale');
            
            if (videoPlane) {
                posElement.textContent = `X: ${videoPlane.position.x.toFixed(2)}, Y: ${videoPlane.position.y.toFixed(2)}`;
                scaleElement.textContent = `Scale: ${overlayScale.toFixed(2)}`;
            }
        }
        
        async function startCamera() {
            try {
                const isMobile = deviceInfo.isMobile || deviceInfo.isTablet;
                
                // Build constraints based on device
                const constraints = {
                    video: {
                        facingMode: { ideal: currentCameraFacing }
                    },
                    audio: false
                };
                
                // Add resolution preferences for mobile
                if (isMobile) {
                    constraints.video.width = { ideal: 1920 };
                    constraints.video.height = { ideal: 1080 };
                } else {
                    constraints.video.width = { ideal: 1920 };
                    constraints.video.height = { ideal: 1080 };
                }
                
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Set up camera video element
                cameraVideo.srcObject = cameraStream;
                cameraVideo.setAttribute('playsinline', 'true');
                cameraVideo.setAttribute('webkit-playsinline', 'true');
                cameraVideo.muted = true;
                
                cameraVideo.onloadedmetadata = () => {
                    cameraVideo.play();
                    
                    // Give time for video to start
                    setTimeout(() => {
                        // Create texture from camera video
                        cameraTexture = new THREE.VideoTexture(cameraVideo);
                        cameraTexture.minFilter = THREE.LinearFilter;
                        cameraTexture.magFilter = THREE.LinearFilter;
                        cameraTexture.format = THREE.RGBAFormat;
                        
                        // Calculate aspect ratios
                        const cameraAspectRatio = cameraVideo.videoWidth / cameraVideo.videoHeight;
                        const formatAspect = currentFormat.planeWidth / currentFormat.planeHeight;
                        
                        console.log(`Camera resolution: ${cameraVideo.videoWidth}x${cameraVideo.videoHeight}`);
                        console.log(`Camera aspect ratio: ${cameraAspectRatio.toFixed(2)}`);
                        console.log(`Format aspect ratio: ${formatAspect.toFixed(2)}`);
                        
                        // Apply "cover" behavior - fill entire plane, crop excess
                        if (cameraAspectRatio > formatAspect) {
                            // Camera is wider than format - crop sides
                            const cropX = formatAspect / cameraAspectRatio;
                            cameraTexture.repeat.set(cropX, 1);
                            cameraTexture.offset.set((1 - cropX) / 2, 0);
                            console.log(`Cover mode: cropping sides (showing ${(cropX * 100).toFixed(1)}% of width)`);
                        } else if (cameraAspectRatio < formatAspect) {
                            // Camera is taller than format - crop top/bottom
                            const cropY = cameraAspectRatio / formatAspect;
                            cameraTexture.repeat.set(1, cropY);
                            cameraTexture.offset.set(0, (1 - cropY) / 2);
                            console.log(`Cover mode: cropping top/bottom (showing ${(cropY * 100).toFixed(1)}% of height)`);
                        } else {
                            // Perfect match
                            cameraTexture.repeat.set(1, 1);
                            cameraTexture.offset.set(0, 0);
                        }
                        
                        // Apply texture to background plane
                        backgroundPlane.material = new THREE.MeshBasicMaterial({
                            map: cameraTexture,
                            side: THREE.DoubleSide
                        });
                        backgroundPlane.material.needsUpdate = true;
                        
                        // Try to enable continuous autofocus
                        const track = cameraStream.getVideoTracks()[0];
                        const capabilities = track.getCapabilities ? track.getCapabilities() : {};
                        
                        if (capabilities.focusMode && capabilities.focusMode.includes('continuous')) {
                            track.applyConstraints({
                                advanced: [{ focusMode: 'continuous' }]
                            }).then(() => {
                                console.log('Continuous autofocus enabled');
                            }).catch(err => {
                                console.log('Could not enable continuous autofocus:', err);
                            });
                        }
                        
                        // Set up periodic refocus as fallback
                        setInterval(() => {
                            if (cameraStream && cameraStream.active) {
                                const track = cameraStream.getVideoTracks()[0];
                                if (track && track.getCapabilities) {
                                    const caps = track.getCapabilities();
                                    if (caps.focusMode) {
                                        track.applyConstraints({
                                            advanced: [{ focusMode: 'continuous' }]
                                        }).catch(() => {});
                                    }
                                }
                            }
                        }, 2000);
                        
                        updateStatus(`Camera started (${cameraVideo.videoWidth}x${cameraVideo.videoHeight}) - Format: ${deviceInfo.format}`);
                    }, 100);
                };
                
                document.getElementById('startCamera').disabled = true;
                document.getElementById('stopCamera').disabled = false;
                document.getElementById('switchCamera').disabled = false;
                
            } catch (error) {
                console.error('Error accessing camera:', error);
                updateStatus('Error: Could not access camera. Please check permissions.');
            }
        }
        
        async function switchCamera() {
            // Toggle facing mode
            currentCameraFacing = currentCameraFacing === 'user' ? 'environment' : 'user';
            
            // Stop current camera
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
            
            // Start with new facing mode
            await startCamera();
            
            updateStatus(`Switched to ${currentCameraFacing === 'user' ? 'front' : 'back'} camera`);
        }
        
        function stopCamera() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            cameraVideo.srcObject = null;
            
            if (cameraTexture) {
                cameraTexture.dispose();
                cameraTexture = null;
            }
            
            backgroundPlane.material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0
            });
            
            document.getElementById('startCamera').disabled = false;
            document.getElementById('stopCamera').disabled = true;
            document.getElementById('switchCamera').disabled = true;
            
            updateStatus('Camera stopped');
        }
        
        function loadVideo(videoKey) {
            // Stop any existing video first
            if (videoElement) {
                videoElement.pause();
                videoElement.src = '';
                videoElement.load();
            }
            
            // Clean up existing texture
            if (videoTexture) {
                videoTexture.dispose();
                videoTexture = null;
            }
            
            // Create new video element for the WebM
            videoElement = document.createElement('video');
            videoElement.crossOrigin = 'anonymous';
            videoElement.loop = true;
            videoElement.muted = true;
            videoElement.playsInline = true;
            videoElement.setAttribute('playsinline', 'true');
            videoElement.setAttribute('webkit-playsinline', 'true');
            
            // Check for WebM support
            const canPlayWebM = videoElement.canPlayType('video/webm; codecs="vp8, vorbis"') || 
                               videoElement.canPlayType('video/webm; codecs="vp9"') ||
                               videoElement.canPlayType('video/webm');
            
            if (!canPlayWebM) {
                console.warn('WebM may not be fully supported on this browser');
                updateStatus('Warning: WebM support may be limited on this device');
            }
            
            videoElement.onloadeddata = () => {
                // Create texture from video
                videoTexture = new THREE.VideoTexture(videoElement);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.format = THREE.RGBAFormat;
                
                // Apply texture to video plane
                videoPlane.material = new THREE.MeshBasicMaterial({
                    map: videoTexture,
                    transparent: true,
                    side: THREE.DoubleSide,
                    alphaTest: 0.1
                });
                videoPlane.material.needsUpdate = true;
                
                videoElement.play().then(() => {
                    isVideoPlaying = true;
                    currentActiveVideo = videoKey;
                    
                    // Update button states
                    document.querySelectorAll('.video-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`[data-video="${videoKey}"]`).classList.add('active');
                    
                    // Show overlay info panel
                    document.getElementById('overlay-info').style.display = 'block';
                    updateOverlayInfo();
                    
                    updateStatus(`Playing ${videoKey} overlay (drag to move, scroll to resize)`);
                }).catch(error => {
                    console.error('Error playing video:', error);
                    updateStatus('Error: Could not play video overlay');
                });
            };
            
            videoElement.onerror = (e) => {
                console.error('Video loading error:', e);
                updateStatus(`Error loading video: ${videoUrls[videoKey]}`);
            };
            
            videoElement.src = videoUrls[videoKey];
            videoElement.load();
        }
        
        function stopVideo() {
            if (videoElement) {
                videoElement.pause();
                videoElement.src = '';
                videoElement.load();
                videoElement = null;
            }
            
            if (videoTexture) {
                videoTexture.dispose();
                videoTexture = null;
            }
            
            videoPlane.material = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0
            });
            videoPlane.material.needsUpdate = true;
            
            isVideoPlaying = false;
            
            // Update button states
            document.querySelectorAll('.video-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            currentActiveVideo = null;
            
            // Hide overlay info panel
            document.getElementById('overlay-info').style.display = 'none';
            
            updateStatus('Video stopped');
        }
        
        function takePhoto() {
            // Instantly take photo - no countdown
            renderer.render(scene, camera);
            
            const canvas = renderer.domElement;
            const dataURL = canvas.toDataURL('image/png');
            
            const preview = document.getElementById('photo-preview');
            preview.src = dataURL;
            preview.style.display = 'block';
            
            const link = document.createElement('a');
            link.download = `photo-${deviceInfo.format}-${Date.now()}.png`;
            link.href = dataURL;
            link.click();
            
            updateStatus(`Photo captured in ${deviceInfo.format} format (${currentFormat.width}x${currentFormat.height})`);
            
            setTimeout(() => {
                preview.style.display = 'none';
            }, 3000);
        }
        
        function recordVideo() {
            if (isRecording) return;
            
            // Instantly start recording - no countdown
            startVideoRecording();
        }
        
        function startVideoRecording() {
            try {
                const canvas = renderer.domElement;
                
                // Use a fixed frame rate for the stream
                const stream = canvas.captureStream(TARGET_FPS);
                
                // Try different codecs for better compatibility and performance
                let options = { videoBitsPerSecond: 5000000 }; // Increased bitrate
                
                // Preferred codec order for smooth recording
                const codecPreferences = [
                    'video/webm;codecs=vp8', // VP8 is generally faster than VP9
                    'video/webm;codecs=vp9',
                    'video/webm'
                ];
                
                for (const codec of codecPreferences) {
                    if (MediaRecorder.isTypeSupported(codec)) {
                        options.mimeType = codec;
                        console.log(`Using codec: ${codec}`);
                        break;
                    }
                }
                
                mediaRecorder = new MediaRecorder(stream, options);
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: options.mimeType || 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    const videoPreview = document.getElementById('video-preview');
                    videoPreview.src = url;
                    videoPreview.style.display = 'block';
                    
                    const link = document.createElement('a');
                    link.download = `video-${deviceInfo.format}-${Date.now()}.webm`;
                    link.href = url;
                    link.click();
                    
                    updateStatus(`10-second video captured in ${deviceInfo.format} format (${currentFormat.width}x${currentFormat.height})`);
                    
                    setTimeout(() => {
                        videoPreview.style.display = 'none';
                        URL.revokeObjectURL(url);
                    }, 5000);
                    
                    document.getElementById('recordVideo').disabled = false;
                    document.getElementById('stopRecording').style.display = 'none';
                    document.getElementById('recordVideo').style.display = 'inline-block';
                    isRecording = false;
                };
                
                // Start recording - use larger timeslice for fewer interruptions
                mediaRecorder.start(1000); // Collect data every 1 second instead of 100ms
                isRecording = true;
                
                document.getElementById('recordVideo').disabled = true;
                document.getElementById('stopRecording').disabled = false;
                document.getElementById('stopRecording').style.display = 'inline-block';
                document.getElementById('recordVideo').style.display = 'none';
                
                const indicator = document.getElementById('recording-indicator');
                const countdownElement = document.getElementById('countdown');
                indicator.style.display = 'block';
                
                let timeLeft = 10;
                countdownElement.textContent = timeLeft;
                
                countdownTimer = setInterval(() => {
                    timeLeft--;
                    countdownElement.textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(countdownTimer);
                    }
                }, 1000);
                
                recordingTimer = setTimeout(() => {
                    stopRecording();
                }, 10000);
                
                updateStatus('Recording 10-second video...');
                
            } catch (error) {
                console.error('Error starting video recording:', error);
                updateStatus('Error: Could not start video recording');
            }
        }
        
        function stopRecording() {
            if (!isRecording) return;
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (recordingTimer) {
                clearTimeout(recordingTimer);
                recordingTimer = null;
            }
            
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            
            document.getElementById('recording-indicator').style.display = 'none';
            
            updateStatus('Recording stopped');
        }
        
        // ========== OPTIMIZED RENDER LOOP ==========
        function animate(currentTime) {
            animationFrameId = requestAnimationFrame(animate);
            
            // Frame rate limiting for consistent timing
            if (currentTime - lastFrameTime < FRAME_DURATION) {
                return; // Skip this frame to maintain consistent FPS
            }
            lastFrameTime = currentTime;
            
            // Update video textures only if they exist and are playing
            // This is more efficient than always setting needsUpdate
            if (videoTexture && isVideoPlaying && videoElement && !videoElement.paused) {
                videoTexture.needsUpdate = true;
            }
            
            if (cameraTexture && cameraVideo && cameraVideo.readyState >= cameraVideo.HAVE_CURRENT_DATA) {
                cameraTexture.needsUpdate = true;
            }
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            updateRendererSize();
        }
        
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }
        
        // Initialize the app
        init();
    </script>
</body>
</html>
